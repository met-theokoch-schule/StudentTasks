{"version":3,"sources":["webpack:///./res/ServiceWorker.js"],"names":["ServiceCache","name","_classCallCheck","this","_name","_assets","_handlers","key","value","asset","push","handler","bind","request","url","result","_step","_iterator","_createForOfIteratorHelper","s","n","done","err","e","f","MANIFEST_ENTRIES","self","__WB_MANIFEST","ASSETS_PREFIX","ASSETS_PREFIXES","GENERATED_ASSETS","map","entry","_i","_ASSETS_PREFIXES","length","prefix","startsWith","slice","APP_CACHE","process","hash","i","charCodeAt","Math","abs","toString","hashString","revision","join","register","addCacheStrategyHandler","test","pathname","cacheStrategyNetworkFirst","destination","cacheStrategyCacheFirst","forEach","ACTIVE_CACHES","ACTIVE_CACHE_NAMES","getName","activeCache","fetchFromNetwork","console","error","then","response","fetchFromCache","createCache","cacheName","assets","arguments","undefined","Error","log","caches","open","cache","addAll","match","ownedCacheName","fetchRequest","clone","fetch","status","type","cacheRequest","cacheResponse","put","addToCache","addEventListener","event","_step2","results","_iterator2","cacheAssets","getAssets","skipWaiting","waitUntil","Promise","all","whitelist","keys","cacheNames","includes","clients","claim","requestURL","URL","method","origin","location","_step3","_iterator3","cacheStrategy","getCacheStrategy","respondWith"],"mappings":"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","file":"dfa-nfa-pda-assets/serviceWorker.js","sourceRoot":"","sourcesContent":["//IMPORTANT: First line of file must NEVER contain code.\n//IMPORTANT: Must NEVER rename this file.\n//IMPORTANT: Must live under the intended scope (see registration in index.html).\n//IMPORTANT: To trigger an update, this file must change. (hopefully this will be automated)\n\n//Be careful about hosting services, they sometimes cache service workers, which\n//would stop them from automatically updating...\n\nclass ServiceCache\n{\n  constructor(name) { this._name = name; this._assets = []; this._handlers = [] }\n  register(asset) { this._assets.push(asset); return this; }\n  addCacheStrategyHandler(handler) { this._handlers.push(handler.bind(this)); return this; }\n  getAssets() { return this._assets; }\n  getName() { return this._name; }\n  getCacheStrategy(request, url)\n  {\n    //console.log(\"[ServiceWorker] Getting cache strategy for \\'\" + url.pathname + \"\\'...\");\n    let result;\n    //Gettin cache strategies...\n    for (const handler of this._handlers) if (result = handler(request, url)) return result;\n    //Could not find valid strategy for request...\n    return null;\n  }\n}\n\nfunction hashString(value)\n{\n  if (!value) return '';\n  let hash = 5381;\n  for (let i = 0; i < value.length; i++) hash = ((hash << 5) + hash) + value.charCodeAt(i);\n  return Math.abs(hash).toString(36);\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CONFIGURATIONS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//For debuggin' purposes, since this will turn off offline caching\nconst FORCE_NETWORK_ONLY = process.env.NODE_ENV === 'development';\n//If you can guarantee to NEVER do lazy-loading pre-cached assets,\n//then this will allow users to get the new ServiceWorker immediately,\n//rather than wait for a redirect (must close browser, then re-enter)\n//before it updates / gets new changes.\nconst FORCE_IMMEDIATE_CLAIM = true;\n//Will invalidate user's cache every build, regardless of version.\n//NOTE: Turn this on for aggressive updates.\nconst USE_CACHE_BUILD_HASH = true;\n\n//Array of assets and a build hash generated by webpack,\n//through the courtesy of workbox InjectManifest.\nconst MANIFEST_ENTRIES = self.__WB_MANIFEST || [];\nconst ASSETS_PREFIX = 'dfa-nfa-pda-assets/';\nconst ASSETS_PREFIXES = [ASSETS_PREFIX, './' + ASSETS_PREFIX, '/' + ASSETS_PREFIX];\nconst GENERATED_ASSETS = MANIFEST_ENTRIES.map(entry =>\n{\n  const url = (typeof entry === 'string' ? entry : entry.url) || '';\n  for (const prefix of ASSETS_PREFIXES)\n  {\n    if (url.startsWith(prefix)) return './' + url.slice(prefix.length);\n  }\n  return url;\n});\nconst GENERATED_HASH = hashString(MANIFEST_ENTRIES.map(entry => (entry && entry.revision) || '').join('|'));\n\n//NOTE: If you are debugging service worker (for I will salute you and wish you\n//good luck), here are some ways to make it easier for you:\n//- You should remove 'host' in the 'devServer' in 'webpack.config.js', this\n//will enable you to test it with hmr (start the test server by 'npm start').\n//- You will also need to copy this file out to the base directory and\n//replace 'serviceWorker.js' (needs to be the same name). Just edit that copy\n//until all the bugs are fixed and then copy back. (Make sure not to run a\n//production build, since that will 'clean' your edited files...)\n//- Also, since optimizations are not computed during development mode, you need\n//to uncomment 'app.bundle.js' below (don't need runtime, vendors, etc.).\n//- Finally, change the cache name to something static like 'app-test', because\n//'global.' and 'process.env.' are no longer available. You'll need to comment\n//them out.\n\n//NOTE: Another tip, any time you are debugging a new feature, be sure to try\n//it with 'offline' mode and 'disable cache' mode on/off. Sometimes, the\n//service worker will cache things that the browser already cached, making\n//your updates futile. So watch out. Until we get a proper server with\n//HTTP headers, we can't tell the browser to not cache stuff.\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CACHES **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//List your caches here!\n\n//Inactive caches...(be sure to add them here for future reference)\n//...apparently there are none yet...\n\n//Active caches...(be sure to append them to ACTIVE_CACHES)\n//- unique cache name (must ALWAYS be different from any prior versions)\n//- assets to cache (every asset list must be disjoint from one another)\nconst APP_CACHE = new ServiceCache(process.env.TITLE + '-' + process.env.VERSION + (USE_CACHE_BUILD_HASH ? '_' + GENERATED_HASH : ''))\n  //Essential app files\n  .register('./') //Always include the root\n  //.register('./index.html')\n  //.register('./dist/app.bundle.js')\n  /*\n  .register('./dist/runtime~app.bundle.js')\n  .register('./dist/vendors.bundle.js')\n  .register('./dist/styles.bundle.js')\n  */\n  //Any other output files\n  .addCacheStrategyHandler((request, url) =>\n  {\n    //Should accept 'index.html'...\n    if (/\\/$/.test(url.pathname)) return cacheStrategyNetworkFirst;\n\n    //Check if is fetch for general destination type of file asset...\n    const dest = request.destination;\n    switch (dest)\n    {\n      case 'style':\n      case 'script':\n      case 'document':\n      case 'image': return cacheStrategyCacheFirst;\n      default: return null;\n    }\n  });\nGENERATED_ASSETS.forEach(asset => APP_CACHE.register(asset));\n\n//Include active caches here...\nconst ACTIVE_CACHES = [APP_CACHE];\nconst ACTIVE_CACHE_NAMES = ACTIVE_CACHES.map(e => e.getName());\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** EVENT HANDLERS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\nfunction onServiceWorkerInstall(event)\n{\n  //Create all active caches...\n  const results = [];\n  for (const cache of ACTIVE_CACHES)\n  {\n    const cacheName = cache.getName();\n    const cacheAssets = cache.getAssets();\n    //Create and load all assets for each active cache...\n    results.push(createCache(cacheName, cacheAssets));\n  }\n\n  if (FORCE_IMMEDIATE_CLAIM) self.skipWaiting();\n\n  //Wait for install to finish...\n  event.waitUntil(Promise.all(results));\n}\n\nfunction onServiceWorkerActivate(event)\n{\n  //Get the names of all current caches...\n  const whitelist = ACTIVE_CACHE_NAMES;\n\n  //Remove any cache not in the whitelist...\n  const result = caches.keys().then(cacheNames => Promise.all(\n    cacheNames.map(cacheName =>\n    {\n      //If the whitelist is missing the cache name, delete it...\n      if (!whitelist || !whitelist.includes(cacheName))\n      {\n        console.log(\"[ServiceWorker] Removing outdated cache \\'\" + cacheName + \"\\'...\");\n        return caches.delete(cacheName);\n      }\n      //Otherwise, keep the cache...\n    })\n  ));\n\n  //Wait for activate to finish...\n  event.waitUntil(result);\n\n  return self.clients.claim();\n}\n\nfunction onServiceWorkerFetch(event)\n{\n  //IMPORTANT: Request objects are streams, therefore can only used once! Clone it!\n  const request = event.request;\n  const requestURL = new URL(request.url);\n\n  if (!FORCE_NETWORK_ONLY &&\n    request.method === 'GET' &&\n    requestURL.origin === self.location.origin)\n  {\n    //Check for each cache, whether it accepts the request...\n    for (const cache of ACTIVE_CACHES)\n    {\n      const cacheStrategy = cache.getCacheStrategy(request, requestURL);\n      if (cacheStrategy)\n      {\n        //Change event's fetch result as resolved by strategy...\n        event.respondWith(cacheStrategy(request, cache));\n        return;\n      }\n    }\n  }\n\n  //Change event's fetch result...\n  event.respondWith(cacheStrategyNetworkFirst(request, null));\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** CACHE STRATEGIES **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\n//Only fetch from network\nfunction cacheStrategyNetworkOnly(request, activeCache)\n{\n  return fetchFromNetwork(request, null);\n}\n\n//Only fetch from cache\nfunction cacheStrategyCacheOnly(request, activeCache)\n{\n  return fetchFromCache(request);\n}\n\n//Always try to fetch network assets first (will fall back to cache if unable to)\nfunction cacheStrategyNetworkFirst(request, activeCache)\n{\n  //Get the request from the network...\n  return fetchFromNetwork(request, activeCache ? activeCache.getName() : null)\n    .catch(e => console.error(\"[ServiceWorker]\", e))\n    //If unable to, try to get it from cache...\n    .then(response => response || fetchFromCache(request));\n}\n\n//Always try to fetch cache assets first (will fall back to network if unable to)\nfunction cacheStrategyCacheFirst(request, activeCache)\n{\n  //Get the request from the network...\n  return fetchFromCache(request)\n    .catch(e => console.error(\"[ServiceWorker]\", e))\n    //If unable to, try to get it from cache...\n    .then(response => response || fetchFromNetwork(request, activeCache ? activeCache.getName() : null));\n}\n\n//Will fetch both simultaneously, and use which ever loads first\nfunction cacheStrategyFastest(request, activeCache)\n{\n  console.error(\"[ServiceWorker] Trying to use cache strategy not yet implemented\");\n  return cacheStrategyCacheFirst(request, activeCache);\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * */\n/********** HELPER FUNCTIONS **********/\n/* * * * * * * * * * * * * * * * * * * * * * */\n\nfunction createCache(cacheName, assets = [])\n{\n  if (typeof cacheName !== 'string') throw new Error(\"Unable to create cache with unknown name\");\n\n  //DEBUG: should only be logged when installing new cached assets...\n  console.log(\"[ServiceWorker] Creating cache \\'\" + cacheName + \"\\' with \" + assets.length + \" asset(s)...\");\n\n  return caches.open(cacheName).then(cache => cache.addAll(assets));\n  //Don't catch the errors; let them be thrown :)\n}\n\nfunction addToCache(cacheName, request, response)\n{\n  if (typeof cacheName !== 'string') throw new Error(\"Unable to add to cache with unknown name\");\n  if (!request) throw new Error(\"Unable to add to cache for null request\");\n\n  //Make sure it's a valid response...\n  if (!response || response.status !== 200 || response.type !== 'basic') return response;\n\n  //IMPORTANT: Request objects are only used once!\n  const cacheRequest = request.clone();\n  const cacheResponse = response.clone();\n\n  //Asynchronously add to cache\n  caches.open(cacheName).then(cache => cache.put(cacheRequest, cacheResponse));\n  //Any thrown errors would be handled automatically\n\n  return response;\n}\n\nfunction fetchFromCache(request)\n{\n  if (!request) throw new Error(\"Unable to resolve fetch from cache for null request\");\n\n  return caches.match(request).then(response =>\n  {\n\n    //DEBUG: should only be logged when missing cached assets...\n    console.log(\"[ServiceWorker] Resolving fetch from cache for \\'\" + request.url + \"\\'...\");\n\n    return response;\n  });\n}\n\nfunction fetchFromNetwork(request, ownedCacheName = null)\n{\n  if (!request) throw new Error(\"Unable to resolve fetch from network for null request\");\n\n  //Make sure to not alter passed-in request...\n  const fetchRequest = request.clone();\n\n  //DEBUG: should only be logged when missing cached assets...\n  console.log(\"[ServiceWorker] Resolving fetch from network for \\'\" + request.url + \"\\'...\");\n\n  return fetch(fetchRequest).then(response =>\n  {\n    //If not caching, just return the response...\n    if (!ownedCacheName) return response;\n\n    return addToCache(ownedCacheName, request, response);\n  });\n}\n\n//Register event handlers\nself.addEventListener('install', onServiceWorkerInstall);\nself.addEventListener('activate', onServiceWorkerActivate);\nself.addEventListener('fetch', onServiceWorkerFetch);\n"]}